import base64, os, time
from collections import defaultdict

import numpy as np
import paho.mqtt.client as mqtt
from joblib import load
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

# ── Konstanta ─────────────────────────────────────────────
NONCE_LEN = 12
AD        = b""

# ── Mapping topik ke key ─────────────────────────────────
TOPIC_KEYS = {
    "PukEOu": bytes([0x60,0x3d,0xeb,0x10,0x15,0xca,0x71,0xbe,0x2b,0x73,0xae,0xf0,0x85,0x7d,0x77,0x81]),
    "BNtjEO": bytes([0x1e,0xf2,0xa6,0x87,0x2a,0x1d,0xa1,0xf3,0x09,0xc6,0xe9,0x85,0x9e,0xb8,0x7c,0x64]),
    "YzMtje": bytes([0x19,0x17,0x9b,0x0f,0x67,0xee,0x01,0x08,0xa6,0xca,0x73,0x42,0xe2,0xd3,0xba,0xd7]),
    "zMtjEO": bytes([0xfc,0x19,0x68,0xfe,0x2a,0x42,0xd8,0x45,0x39,0xa8,0xf7,0x55,0x75,0x0c,0xcd,0xa0]),
    "FPuJRV": bytes([0xa3,0xf2,0x78,0x5b,0x6f,0x00,0x4b,0xad,0x80,0xf3,0xb6,0x76,0x1a,0x26,0x38,0x9e]),
    "cbAMtj": bytes([0x4f,0xa2,0xd9,0x6c,0x81,0x05,0xbe,0x33,0x7a,0xc8,0x10,0xf4,0x2d,0x9e,0x56,0x0b]),
    "zMSVxl": bytes([0x9c,0x3a,0x71,0xe0,0x4b,0x22,0xf9,0x8d,0x5e,0xb1,0x60,0x07,0xac,0x34,0xd2,0x18]),
    "dbAngd": bytes([0x2b,0x6f,0x90,0xcd,0x13,0x47,0xae,0x5a,0x84,0xf1,0x39,0x02,0x7d,0xb6,0xe8,0x25]),
    "GgieBn": bytes([0xff,0x11,0x63,0x8a,0x2e,0xd4,0x59,0x70,0xc3,0x96,0x0f,0xa8,0x4d,0x21,0xbe,0x5c]),
    "azMtje": bytes([0x30,0x87,0x1a,0xb4,0xe6,0x9f,0x42,0xdd,0x05,0x6b,0xcc,0x73,0x28,0x94,0xf0,0x3d]),
    "aaazMt": bytes([0x6a,0xc1,0x0e,0x55,0x9b,0x38,0xf7,0x24,0xd0,0x4c,0x81,0xae,0x13,0x6e,0xb9,0x47]),
    "SVXYYY": bytes([0x17,0xe9,0x4b,0x92,0xfa,0x36,0x0c,0xd7,0x5f,0xa3,0x78,0x21,0xce,0x64,0x8d,0x0a]),
    "MtjeBn": bytes([0xb2,0x5d,0x03,0x8f,0x46,0xc9,0x71,0x1e,0xda,0x20,0x9a,0x67,0xf3,0x4e,0x0b,0x85]),
    "lFpHqi": bytes([0x88,0x2c,0xf6,0x49,0x35,0xbd,0x0a,0x67,0xce,0x11,0x9f,0x52,0xa4,0x7b,0x03,0xd8]),
    "HQUWXy": bytes([0x5b,0x90,0x2f,0xae,0x14,0x63,0xcc,0x08,0xf2,0x7d,0x31,0xb7,0x4a,0xe5,0x99,0x20]),
    "lfcbAn": bytes([0x0d,0xb8,0x4f,0x26,0x71,0x95,0xea,0x3c,0x52,0x06,0xcf,0x84,0x1b,0xd3,0x60,0x9e]),
    "JriecA": bytes([0xc7,0x34,0x5a,0x01,0x8e,0xf5,0x2b,0x69,0xd6,0x48,0x13,0xa0,0x7f,0x2d,0x94,0xbe]),
    "AMSVXY": bytes([0x21,0x6d,0x8b,0xf0,0x3e,0x57,0xac,0x02,0xd9,0x41,0x73,0x9c,0x05,0xbe,0x68,0x14]),
    "vkEOuk": bytes([0xa9,0x0f,0x36,0xde,0x4c,0x82,0x51,0xb3,0x7e,0x19,0xc5,0x20,0x96,0xfd,0x2a,0x64]),
    "iDOTwl": bytes([0x3c,0xe2,0x57,0x8d,0x09,0xb0,0x6f,0x14,0xd1,0x84,0x2e,0x7a,0xcf,0x35,0x90,0xab]),
    "cbaaaa": bytes([0x72,0x49,0x0b,0xf8,0x25,0xd6,0x9e,0x31,0x64,0xbc,0x07,0xa5,0x1c,0xef,0x58,0x03]),
    "AMSVxl": bytes([0x56,0x13,0xda,0x8c,0x40,0xbe,0x29,0x97,0xf4,0x0e,0x63,0xb1,0x2a,0x75,0x9d,0x08]),
    "NTwlFP": bytes([0xed,0x04,0x6b,0x90,0x3f,0xc2,0x58,0x1a,0x7c,0xa6,0x11,0xd5,0x2e,0x8b,0x47,0xf9]),
    "DOuJri": bytes([0x0a,0x7f,0xc6,0x35,0x98,0x24,0xbe,0x51,0xd2,0x69,0x03,0xaf,0x46,0x8e,0x1d,0x70]),
    "EOTwlf": bytes([0x39,0xb5,0x02,0xe7,0x6c,0x81,0x4a,0xd0,0x95,0x18,0xfc,0x27,0x53,0x9b,0x40,0x6e]),
}

# ── Model ML ──────────────────────────────────────────────
model  = load("model_svm_new.pkl")
scaler = load("scaler_new.pkl")
label_map = {0: "Diam", 1: "Jalan", 2: "Lari", 3: "Kendaraan"}

# ── Rate-limit cache ─────────────────────────────────────
RATE_LIMIT = 1.0
LAST_SEEN  = defaultdict(lambda: {"payload": None, "ts": 0.0})

# ── Fungsi dekripsi ──────────────────────────────────────
def try_decrypt(enc_b64: bytes, key: bytes) -> str | None:
    try:
        enc = base64.b64decode(enc_b64, validate=True)
    except Exception:
        print(" Base64 decode gagal")
        return None
    if len(enc) <= NONCE_LEN + 16:
        print(" Payload terlalu pendek")
        return None

    nonce, ct_tag = enc[:NONCE_LEN], enc[NONCE_LEN:]
    aesgcm = AESGCM(key)
    try:
        pt = aesgcm.decrypt(nonce, ct_tag, AD)
        if b"," in pt:
            return pt.decode().strip()
    except Exception as e:
        print(f" Decrypt gagal: {e}")
    return None

# ── Callback MQTT ────────────────────────────────────────
def on_connect(c, u, f, rc):
    print(" Terhubung ke broker MQTT, kode:", rc)
    c.subscribe("#")

def on_message(c, u, msg):
    if msg.topic.startswith("hasil/"):
        return

    token = msg.topic.split("/")[-1]
    now = time.monotonic()

    key = TOPIC_KEYS.get(token)
    if not key:
        print(f" Tidak ada key untuk token: {token}")
        return

    # ⏱ Dekripsi
    t0_decrypt = time.perf_counter()
    plain = try_decrypt(msg.payload.strip(), key)
    t1_decrypt = time.perf_counter()
    decrypt_time_ms = (t1_decrypt - t0_decrypt) * 1000

    if plain is None:
        print(f" Tidak dapat didekripsi (topic: {msg.topic})")
        return

    if plain == LAST_SEEN[token]["payload"]:
        print(" Payload sama → dilewati")
        return
    if now - LAST_SEEN[token]["ts"] < RATE_LIMIT:
        print(" Rate limit → dilewati")
        return

    LAST_SEEN[token].update(payload=plain, ts=now)

    parts = plain.split(",")
    if len(parts) < 11:
        print(" Format data tidak lengkap:", plain)
        return

    try:
        device_time  = parts[0]
        batt_pct     = float(parts[1])
        lat          = float(parts[2])
        lon          = float(parts[3])
        temp         = float(parts[4])
        hum          = float(parts[5])
        x            = float(parts[6])
        y            = float(parts[7])
        z            = float(parts[8])
        speed        = float(parts[9])
        token_rx     = parts[10]
    except ValueError as e:
        print(f" Format data salah: {e}")
        print(" Payload:", plain)
        return

    # Cek token payload
    if token_rx != token:
        print(f" Token mismatch! MQTT={token}, Payload={token_rx}")

    # --- Prediksi ML ---
    data_scaled = scaler.transform([[x, y, z]])
    t0_ml = time.perf_counter()
    pred = model.predict(data_scaled)[0]
    t1_ml = time.perf_counter()
    ml_time_ms = (t1_ml - t0_ml) * 1000
    aktivitas = label_map.get(pred, "Tidak diketahui")

    # --- Output CSV ---
    csv_out = (
        f"{device_time},{batt_pct:.0f},"
        f"{lat:.5f},{lon:.5f},"
        f"{temp:.2f},{hum:.2f},"
        f"{x:.2f},{y:.2f},{z:.2f},{speed:.2f},"
        f"{aktivitas}"
    )

    print(" Plaintext:", csv_out)

    # ⏱ Enkripsi
    t0_encrypt = time.perf_counter()
    nonce_out   = os.urandom(NONCE_LEN)
    aesgcm_out  = AESGCM(key)
    ct_tag_out  = aesgcm_out.encrypt(nonce_out, csv_out.encode(), AD)
    enc_payload = base64.b64encode(nonce_out + ct_tag_out).decode()
    t1_encrypt = time.perf_counter()

    # ⏱ Publish
    t0_pub = time.perf_counter()
    c.publish(f"hasil/{token}", enc_payload, qos=0, retain=True)
    t1_pub = time.perf_counter()

    print(f"→ hasil/{token} (len = {len(enc_payload)} B)")
    print(f" Dekripsi   : {decrypt_time_ms:.2f} ms")
    print(f" ML Prediksi: {ml_time_ms:.2f} ms")
    print(f" Enkripsi   : {(t1_encrypt - t0_encrypt)*1000:.2f} ms")
    print(f" Kirim MQTT : {(t1_pub - t0_pub)*1000:.2f} ms")
    print("--------------------------------------------------")

# ── Mulai MQTT client ────────────────────────────────────
client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message
client.connect("[IP BROKER MQTT]", 1883, 60)
client.loop_forever()
